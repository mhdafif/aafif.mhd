[
  {
    "id": 1,
    "slug": "building-modern-web-apps-with-astro",
    "title": "Building Modern Web Apps with Astro: A Developer's Journey",
    "excerpt": "Discover how Astro revolutionizes web development with its island architecture and zero-JS by default approach. Learn why it's becoming my go-to framework for building fast, content-focused websites.",
    "content": "# Building Modern Web Apps with Astro: A Developer's Journey\n\nAs a frontend developer who's worked with React, Vue, and various other frameworks, I was initially skeptical when I first heard about Astro. Another JavaScript framework? Really? But after diving deep into Astro's philosophy and building several projects with it, I can confidently say it's changed how I think about web development.\n\n## What Makes Astro Different?\n\nAstro's core philosophy is simple yet revolutionary: **ship less JavaScript**. While other frameworks hydrate entire pages with JavaScript, Astro only hydrates the components that actually need interactivity. This \"islands architecture\" means your site loads faster and performs better out of the box.\n\n## The Island Architecture\n\nImagine your webpage as an ocean with small islands of interactivity. Most of your content (the ocean) is static HTML and CSS, while only specific components (the islands) contain JavaScript. This approach dramatically reduces bundle sizes and improves performance.\n\n```astro\n---\n// This runs at build time, not in the browser\nconst posts = await fetch('/api/posts').then(r => r.json());\n---\n\n<Layout>\n  <h1>My Blog</h1>\n  {posts.map(post => (\n    <article>\n      <h2>{post.title}</h2>\n      <p>{post.excerpt}</p>\n      <!-- This component will be interactive -->\n      <LikeButton client:load />\n    </article>\n  ))}\n</Layout>\n```\n\n## Performance Benefits\n\nIn my experience, Astro sites consistently score 100/100 on Lighthouse performance audits. The secret? By default, Astro generates static HTML with zero client-side JavaScript. You only add JavaScript when you explicitly need it.\n\n## Developer Experience\n\nWhat I love most about Astro is how familiar it feels. You can use React, Vue, Svelte, or even vanilla JavaScript components within the same project. It's like having the best of all worlds.\n\n## Conclusion\n\nAstro isn't just another framework—it's a paradigm shift toward performance-first web development. If you're building content-heavy sites or want to improve your site's performance without sacrificing developer experience, give Astro a try.\n\nYou might just find, like I did, that less JavaScript leads to more joy in web development.",
    "publishedAt": "2024-01-15",
    "readTime": "5 min read",
    "tags": ["Astro", "Web Development", "Performance", "JavaScript"],
    "featured": true
  },
  {
    "id": 2,
    "slug": "mastering-tailwind-css-best-practices",
    "title": "Mastering Tailwind CSS: Best Practices for Scalable Design Systems",
    "excerpt": "Learn how to build maintainable and scalable design systems with Tailwind CSS. From custom configurations to component patterns, discover the strategies that have transformed my development workflow.",
    "content": "# Mastering Tailwind CSS: Best Practices for Scalable Design Systems\n\nTailwind CSS has fundamentally changed how I approach styling web applications. What started as skepticism about \"utility-first\" CSS has evolved into genuine appreciation for its power and flexibility. Here's what I've learned about building scalable design systems with Tailwind.\n\n## The Utility-First Mindset\n\nThe biggest mental shift when adopting Tailwind is moving from component-based CSS to utility-first thinking. Instead of creating `.card` or `.button` classes, you compose styles directly in your HTML using utilities like `bg-white`, `shadow-lg`, and `rounded-lg`.\n\n```html\n<!-- Traditional CSS approach -->\n<div class=\"card\">\n  <h2 class=\"card-title\">Hello World</h2>\n  <p class=\"card-content\">This is a card component.</p>\n</div>\n\n<!-- Tailwind approach -->\n<div class=\"bg-white shadow-lg rounded-lg p-6\">\n  <h2 class=\"text-xl font-bold mb-2\">Hello World</h2>\n  <p class=\"text-gray-600\">This is a card component.</p>\n</div>\n```\n\n## Custom Configuration is Key\n\nOne of Tailwind's greatest strengths is its configurability. Don't just use the default theme—customize it to match your design system:\n\n```javascript\n// tailwind.config.js\nmodule.exports = {\n  theme: {\n    extend: {\n      colors: {\n        primary: {\n          50: '#f0f9ff',\n          500: '#3b82f6',\n          900: '#1e3a8a',\n        },\n        brand: {\n          light: '#fbbf24',\n          DEFAULT: '#f59e0b',\n          dark: '#d97706',\n        }\n      },\n      fontFamily: {\n        sans: ['Inter', 'system-ui', 'sans-serif'],\n      },\n      spacing: {\n        '18': '4.5rem',\n        '88': '22rem',\n      }\n    }\n  }\n}\n```\n\n## Component Patterns That Work\n\nWhile Tailwind is utility-first, you'll still want to create reusable components. Here are patterns I've found effective:\n\n### 1. Component Classes with @apply\n\n```css\n.btn {\n  @apply px-4 py-2 rounded-lg font-medium transition-colors;\n}\n\n.btn-primary {\n  @apply bg-blue-500 text-white hover:bg-blue-600;\n}\n\n.btn-secondary {\n  @apply bg-gray-200 text-gray-900 hover:bg-gray-300;\n}\n```\n\n### 2. Variant-Based Components\n\n```jsx\nconst Button = ({ variant = 'primary', size = 'md', children, ...props }) => {\n  const baseClasses = 'font-medium rounded-lg transition-colors';\n  \n  const variants = {\n    primary: 'bg-blue-500 text-white hover:bg-blue-600',\n    secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300',\n    outline: 'border-2 border-blue-500 text-blue-500 hover:bg-blue-50'\n  };\n  \n  const sizes = {\n    sm: 'px-3 py-1.5 text-sm',\n    md: 'px-4 py-2',\n    lg: 'px-6 py-3 text-lg'\n  };\n  \n  return (\n    <button \n      className={`${baseClasses} ${variants[variant]} ${sizes[size]}`}\n      {...props}\n    >\n      {children}\n    </button>\n  );\n};\n```\n\n## Responsive Design Made Easy\n\nTailwind's responsive utilities make it incredibly easy to create responsive designs:\n\n```html\n<div class=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\n  <div class=\"p-4 bg-white rounded-lg shadow\">\n    <!-- Card content -->\n  </div>\n</div>\n```\n\n## Performance Considerations\n\nTailwind's purge feature ensures you only ship the CSS you actually use:\n\n```javascript\n// tailwind.config.js\nmodule.exports = {\n  content: [\n    './src/**/*.{html,js,jsx,ts,tsx,astro}',\n  ],\n  // ... rest of config\n}\n```\n\n## Dark Mode Support\n\nImplementing dark mode with Tailwind is straightforward:\n\n```html\n<div class=\"bg-white dark:bg-gray-900 text-gray-900 dark:text-white\">\n  <h1 class=\"text-2xl font-bold\">Hello World</h1>\n</div>\n```\n\n## Conclusion\n\nTailwind CSS isn't just about utility classes—it's about building design systems that scale. By embracing its utility-first approach while creating thoughtful component abstractions, you can build maintainable, performant, and beautiful user interfaces.\n\nThe key is finding the right balance between utilities and components for your specific use case. Start with utilities, identify patterns, and abstract when it makes sense.",
    "publishedAt": "2024-01-08",
    "readTime": "7 min read",
    "tags": ["Tailwind CSS", "CSS", "Design Systems", "Frontend"],
    "featured": true
  },
  {
    "id": 3,
    "slug": "typescript-tips-for-react-developers",
    "title": "TypeScript Tips Every React Developer Should Know",
    "excerpt": "Elevate your React development with these essential TypeScript patterns and techniques. From advanced type definitions to performance optimizations, learn how to write more robust React applications.",
    "content": "# TypeScript Tips Every React Developer Should Know\n\nTypeScript has become an essential tool in modern React development. After years of writing TypeScript React applications, I've discovered patterns and techniques that significantly improve code quality and developer experience. Here are the most impactful tips I wish I knew when starting out.\n\n## 1. Master Component Prop Types\n\nDefining proper prop types is fundamental to TypeScript React development:\n\n```tsx\ninterface ButtonProps {\n  variant: 'primary' | 'secondary' | 'outline';\n  size?: 'sm' | 'md' | 'lg';\n  disabled?: boolean;\n  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;\n  children: React.ReactNode;\n}\n\nconst Button: React.FC<ButtonProps> = ({ \n  variant, \n  size = 'md', \n  disabled = false, \n  onClick, \n  children \n}) => {\n  return (\n    <button \n      className={`btn btn-${variant} btn-${size}`}\n      disabled={disabled}\n      onClick={onClick}\n    >\n      {children}\n    </button>\n  );\n};\n```\n\n## 2. Use Generic Components for Reusability\n\nGeneric components provide type safety while maintaining flexibility:\n\n```tsx\ninterface ListProps<T> {\n  items: T[];\n  renderItem: (item: T, index: number) => React.ReactNode;\n  keyExtractor: (item: T) => string | number;\n}\n\nfunction List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li key={keyExtractor(item)}>\n          {renderItem(item, index)}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Usage\n<List\n  items={users}\n  renderItem={(user) => <span>{user.name}</span>}\n  keyExtractor={(user) => user.id}\n/>\n```\n\n## 3. Leverage Union Types for State Management\n\nUnion types make state management more predictable:\n\n```tsx\ntype LoadingState = \n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; data: User[] }\n  | { status: 'error'; error: string };\n\nconst UserList: React.FC = () => {\n  const [state, setState] = useState<LoadingState>({ status: 'idle' });\n\n  const fetchUsers = async () => {\n    setState({ status: 'loading' });\n    try {\n      const users = await api.getUsers();\n      setState({ status: 'success', data: users });\n    } catch (error) {\n      setState({ status: 'error', error: error.message });\n    }\n  };\n\n  switch (state.status) {\n    case 'idle':\n      return <button onClick={fetchUsers}>Load Users</button>;\n    case 'loading':\n      return <div>Loading...</div>;\n    case 'success':\n      return <UserGrid users={state.data} />;\n    case 'error':\n      return <div>Error: {state.error}</div>;\n  }\n};\n```\n\n## 4. Create Utility Types for Common Patterns\n\nUtility types reduce boilerplate and improve consistency:\n\n```tsx\n// API response wrapper\ntype ApiResponse<T> = {\n  data: T;\n  message: string;\n  success: boolean;\n};\n\n// Form field props\ntype FormFieldProps<T> = {\n  name: keyof T;\n  value: T[keyof T];\n  onChange: (name: keyof T, value: T[keyof T]) => void;\n  error?: string;\n};\n\n// Component with forwarded ref\ntype ComponentWithRef<T, P = {}> = React.ForwardRefExoticComponent<\n  P & React.RefAttributes<T>\n>;\n```\n\n## 5. Use Strict Event Handlers\n\nProperly type event handlers for better IntelliSense and error catching:\n\n```tsx\ninterface FormProps {\n  onSubmit: (data: FormData) => void;\n}\n\nconst ContactForm: React.FC<FormProps> = ({ onSubmit }) => {\n  const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    const formData = new FormData(event.currentTarget);\n    onSubmit(formData);\n  };\n\n  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const { name, value } = event.target;\n    // Handle input change\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input \n        name=\"email\" \n        type=\"email\" \n        onChange={handleInputChange}\n      />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n};\n```\n\n## 6. Implement Proper Error Boundaries\n\nType-safe error boundaries improve error handling:\n\n```tsx\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  error?: Error;\n}\n\nclass ErrorBoundary extends React.Component<\n  React.PropsWithChildren<{}>,\n  ErrorBoundaryState\n> {\n  constructor(props: React.PropsWithChildren<{}>) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error('Error caught by boundary:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"error-boundary\">\n          <h2>Something went wrong.</h2>\n          <details>\n            {this.state.error?.message}\n          </details>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n```\n\n## 7. Use Discriminated Unions for Complex Props\n\nDiscriminated unions prevent invalid prop combinations:\n\n```tsx\ntype ButtonProps = \n  | {\n      variant: 'link';\n      href: string;\n      onClick?: never;\n    }\n  | {\n      variant: 'button';\n      href?: never;\n      onClick: () => void;\n    };\n\nconst Button: React.FC<ButtonProps> = (props) => {\n  if (props.variant === 'link') {\n    return <a href={props.href}>Link Button</a>;\n  }\n  \n  return <button onClick={props.onClick}>Regular Button</button>;\n};\n```\n\n## Conclusion\n\nThese TypeScript patterns have significantly improved my React development experience. They provide better IntelliSense, catch errors at compile time, and make code more maintainable. Start incorporating these patterns gradually, and you'll find your React applications become more robust and enjoyable to work with.\n\nRemember, TypeScript is a tool to help you write better JavaScript—embrace its power, but don't let it get in the way of shipping great products.",
    "publishedAt": "2024-01-01",
    "readTime": "8 min read",
    "tags": ["TypeScript", "React", "JavaScript", "Frontend"],
    "featured": false
  },
  {
    "id": 4,
    "slug": "optimizing-react-performance",
    "title": "React Performance Optimization: Beyond the Basics",
    "excerpt": "Dive deep into advanced React performance optimization techniques. Learn about profiling, memoization strategies, and architectural patterns that can dramatically improve your app's performance.",
    "content": "# React Performance Optimization: Beyond the Basics\n\nPerformance optimization in React goes far beyond just adding `React.memo()` to your components. After optimizing numerous React applications, I've learned that true performance gains come from understanding React's rendering behavior and applying the right techniques at the right time.\n\n## Understanding React's Rendering Process\n\nBefore optimizing, it's crucial to understand when and why React re-renders components:\n\n1. **State changes** in the component\n2. **Props changes** from parent components\n3. **Parent re-renders** (unless memoized)\n4. **Context value changes**\n\n## Profiling: Measure Before You Optimize\n\nAlways profile before optimizing. React DevTools Profiler is your best friend:\n\n```jsx\n// Wrap your app with Profiler in development\nimport { Profiler } from 'react';\n\nfunction onRenderCallback(id, phase, actualDuration) {\n  console.log('Component:', id, 'Phase:', phase, 'Duration:', actualDuration);\n}\n\n<Profiler id=\"App\" onRender={onRenderCallback}>\n  <App />\n</Profiler>\n```\n\n## Smart Memoization Strategies\n\n### 1. React.memo with Custom Comparison\n\n```jsx\nconst ExpensiveComponent = React.memo(({ user, settings }) => {\n  // Expensive rendering logic\n  return <div>{/* Complex UI */}</div>;\n}, (prevProps, nextProps) => {\n  // Custom comparison logic\n  return (\n    prevProps.user.id === nextProps.user.id &&\n    prevProps.settings.theme === nextProps.settings.theme\n  );\n});\n```\n\n### 2. useMemo for Expensive Calculations\n\n```jsx\nconst DataVisualization = ({ data, filters }) => {\n  const processedData = useMemo(() => {\n    return data\n      .filter(item => filters.includes(item.category))\n      .map(item => ({\n        ...item,\n        computed: expensiveCalculation(item)\n      }))\n      .sort((a, b) => b.computed - a.computed);\n  }, [data, filters]);\n\n  return <Chart data={processedData} />;\n};\n```\n\n### 3. useCallback for Event Handlers\n\n```jsx\nconst TodoList = ({ todos, onToggle, onDelete }) => {\n  const handleToggle = useCallback((id) => {\n    onToggle(id);\n  }, [onToggle]);\n\n  const handleDelete = useCallback((id) => {\n    onDelete(id);\n  }, [onDelete]);\n\n  return (\n    <ul>\n      {todos.map(todo => (\n        <TodoItem\n          key={todo.id}\n          todo={todo}\n          onToggle={handleToggle}\n          onDelete={handleDelete}\n        />\n      ))}\n    </ul>\n  );\n};\n```\n\n## State Management Optimization\n\n### 1. State Colocation\n\nKeep state as close to where it's used as possible:\n\n```jsx\n// ❌ Bad: State too high up\nconst App = () => {\n  const [userProfile, setUserProfile] = useState(null);\n  const [modalOpen, setModalOpen] = useState(false);\n  \n  return (\n    <div>\n      <Header />\n      <UserProfile user={userProfile} />\n      <Modal isOpen={modalOpen} onClose={() => setModalOpen(false)} />\n    </div>\n  );\n};\n\n// ✅ Good: State colocated\nconst App = () => {\n  return (\n    <div>\n      <Header />\n      <UserProfileSection />\n      <ModalSection />\n    </div>\n  );\n};\n```\n\n### 2. State Normalization\n\nNormalize complex state structures:\n\n```jsx\n// ❌ Bad: Nested state\nconst [state, setState] = useState({\n  users: [\n    { id: 1, name: 'John', posts: [{ id: 1, title: 'Hello' }] }\n  ]\n});\n\n// ✅ Good: Normalized state\nconst [state, setState] = useState({\n  users: { 1: { id: 1, name: 'John', postIds: [1] } },\n  posts: { 1: { id: 1, title: 'Hello', userId: 1 } }\n});\n```\n\n## Context Optimization\n\n### 1. Split Contexts by Update Frequency\n\n```jsx\n// ❌ Bad: Single context with mixed concerns\nconst AppContext = createContext();\n\n// ✅ Good: Separate contexts\nconst UserContext = createContext(); // Changes rarely\nconst ThemeContext = createContext(); // Changes occasionally\nconst NotificationContext = createContext(); // Changes frequently\n```\n\n### 2. Memoize Context Values\n\n```jsx\nconst ThemeProvider = ({ children }) => {\n  const [theme, setTheme] = useState('light');\n  \n  const value = useMemo(() => ({\n    theme,\n    setTheme,\n    colors: theme === 'light' ? lightColors : darkColors\n  }), [theme]);\n  \n  return (\n    <ThemeContext.Provider value={value}>\n      {children}\n    </ThemeContext.Provider>\n  );\n};\n```\n\n## Component Architecture Patterns\n\n### 1. Compound Components\n\n```jsx\nconst Select = ({ children, value, onChange }) => {\n  return (\n    <SelectContext.Provider value={{ value, onChange }}>\n      <div className=\"select\">{children}</div>\n    </SelectContext.Provider>\n  );\n};\n\nSelect.Option = ({ value, children }) => {\n  const { value: selectedValue, onChange } = useContext(SelectContext);\n  return (\n    <div \n      className={`option ${selectedValue === value ? 'selected' : ''}`}\n      onClick={() => onChange(value)}\n    >\n      {children}\n    </div>\n  );\n};\n\n// Usage\n<Select value={selected} onChange={setSelected}>\n  <Select.Option value=\"react\">React</Select.Option>\n  <Select.Option value=\"vue\">Vue</Select.Option>\n</Select>\n```\n\n### 2. Render Props for Logic Reuse\n\n```jsx\nconst DataFetcher = ({ url, children }) => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    fetchData(url)\n      .then(setData)\n      .catch(setError)\n      .finally(() => setLoading(false));\n  }, [url]);\n\n  return children({ data, loading, error });\n};\n\n// Usage\n<DataFetcher url=\"/api/users\">\n  {({ data, loading, error }) => {\n    if (loading) return <Spinner />;\n    if (error) return <Error message={error.message} />;\n    return <UserList users={data} />;\n  }}\n</DataFetcher>\n```\n\n## Bundle Optimization\n\n### 1. Code Splitting with React.lazy\n\n```jsx\nconst LazyComponent = React.lazy(() => import('./HeavyComponent'));\n\nconst App = () => {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <LazyComponent />\n    </Suspense>\n  );\n};\n```\n\n### 2. Preloading Critical Components\n\n```jsx\n// Preload on hover\nconst PreloadableLink = ({ to, children }) => {\n  const handleMouseEnter = () => {\n    import('./TargetComponent'); // Preload\n  };\n  \n  return (\n    <Link to={to} onMouseEnter={handleMouseEnter}>\n      {children}\n    </Link>\n  );\n};\n```\n\n## Conclusion\n\nReact performance optimization is about making informed decisions based on actual performance bottlenecks, not premature optimization. Use profiling tools, understand your app's rendering patterns, and apply these techniques judiciously.\n\nRemember: the best optimization is often architectural—designing your components and state management to minimize unnecessary work in the first place.",
    "publishedAt": "2023-12-20",
    "readTime": "10 min read",
    "tags": ["React", "Performance", "Optimization", "JavaScript"],
    "featured": false
  },
  {
    "id": 5,
    "slug": "modern-css-techniques-2024",
    "title": "Modern CSS Techniques Every Developer Should Know in 2024",
    "excerpt": "Explore the latest CSS features and techniques that are changing how we build user interfaces. From container queries to cascade layers, discover what's new in the CSS landscape.",
    "content": "# Modern CSS Techniques Every Developer Should Know in 2024\n\nCSS has evolved dramatically in recent years. New features like container queries, cascade layers, and advanced selectors are changing how we approach styling. Here are the modern CSS techniques that every developer should know in 2024.\n\n## Container Queries: The Game Changer\n\nContainer queries allow components to respond to their container's size, not just the viewport:\n\n```css\n.card-container {\n  container-type: inline-size;\n  container-name: card;\n}\n\n.card {\n  padding: 1rem;\n}\n\n@container card (min-width: 300px) {\n  .card {\n    display: grid;\n    grid-template-columns: 1fr 2fr;\n    gap: 1rem;\n  }\n}\n\n@container card (min-width: 500px) {\n  .card {\n    padding: 2rem;\n    grid-template-columns: 1fr 1fr 1fr;\n  }\n}\n```\n\n## Cascade Layers: Better CSS Organization\n\nCascade layers provide explicit control over CSS specificity:\n\n```css\n@layer reset, base, components, utilities;\n\n@layer reset {\n  * {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n  }\n}\n\n@layer base {\n  body {\n    font-family: system-ui, sans-serif;\n    line-height: 1.6;\n  }\n}\n\n@layer components {\n  .button {\n    padding: 0.5rem 1rem;\n    border: none;\n    border-radius: 0.25rem;\n    background: blue;\n    color: white;\n  }\n}\n\n@layer utilities {\n  .text-center { text-align: center; }\n  .hidden { display: none; }\n}\n```\n\n## Advanced Selectors\n\n### :has() - The Parent Selector\n\n```css\n/* Style cards that contain images */\n.card:has(img) {\n  border: 2px solid gold;\n}\n\n/* Style forms with invalid inputs */\n.form:has(input:invalid) {\n  border-color: red;\n}\n\n/* Style articles without headings */\narticle:not(:has(h1, h2, h3)) {\n  padding-top: 2rem;\n}\n```\n\n### :is() and :where() for Grouping\n\n```css\n/* :is() maintains specificity */\n:is(h1, h2, h3) {\n  margin-top: 0;\n  margin-bottom: 1rem;\n}\n\n/* :where() has zero specificity */\n:where(button, .btn) {\n  padding: 0.5rem 1rem;\n  border: none;\n  cursor: pointer;\n}\n```\n\n## Modern Layout Techniques\n\n### Intrinsic Web Design with Grid\n\n```css\n.grid-auto-fit {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n  gap: 1rem;\n}\n\n.grid-auto-fill {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n  gap: 1rem;\n}\n```\n\n### Subgrid for Nested Layouts\n\n```css\n.parent-grid {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  gap: 1rem;\n}\n\n.child-grid {\n  display: grid;\n  grid-column: span 2;\n  grid-template-columns: subgrid;\n  gap: inherit;\n}\n```\n\n## Custom Properties (CSS Variables) Advanced Usage\n\n### Dynamic Color Schemes\n\n```css\n:root {\n  --hue: 220;\n  --saturation: 70%;\n  --lightness: 50%;\n  \n  --primary: hsl(var(--hue) var(--saturation) var(--lightness));\n  --primary-light: hsl(var(--hue) var(--saturation) calc(var(--lightness) + 20%));\n  --primary-dark: hsl(var(--hue) var(--saturation) calc(var(--lightness) - 20%));\n}\n\n.theme-blue {\n  --hue: 220;\n}\n\n.theme-green {\n  --hue: 120;\n}\n\n.theme-red {\n  --hue: 0;\n}\n```\n\n### Responsive Typography with Clamp\n\n```css\n:root {\n  --font-size-sm: clamp(0.875rem, 0.8rem + 0.375vw, 1rem);\n  --font-size-base: clamp(1rem, 0.9rem + 0.5vw, 1.125rem);\n  --font-size-lg: clamp(1.125rem, 1rem + 0.625vw, 1.25rem);\n  --font-size-xl: clamp(1.25rem, 1.1rem + 0.75vw, 1.5rem);\n  --font-size-2xl: clamp(1.5rem, 1.3rem + 1vw, 2rem);\n}\n\nh1 { font-size: var(--font-size-2xl); }\nh2 { font-size: var(--font-size-xl); }\np { font-size: var(--font-size-base); }\n```\n\n## Modern Animation Techniques\n\n### View Transitions API\n\n```css\n@view-transition {\n  navigation: auto;\n}\n\n::view-transition-old(root) {\n  animation: slide-out 0.3s ease-out;\n}\n\n::view-transition-new(root) {\n  animation: slide-in 0.3s ease-out;\n}\n\n@keyframes slide-out {\n  to { transform: translateX(-100%); }\n}\n\n@keyframes slide-in {\n  from { transform: translateX(100%); }\n}\n```\n\n### Scroll-Driven Animations\n\n```css\n@keyframes reveal {\n  from {\n    opacity: 0;\n    transform: translateY(50px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n.reveal-on-scroll {\n  animation: reveal linear;\n  animation-timeline: view();\n  animation-range: entry 0% entry 100%;\n}\n```\n\n## Logical Properties for Internationalization\n\n```css\n/* Instead of margin-left/right */\n.element {\n  margin-inline-start: 1rem;\n  margin-inline-end: 2rem;\n  padding-block: 1rem;\n  border-inline-start: 2px solid blue;\n}\n\n/* Writing mode aware */\n.sidebar {\n  inline-size: 250px; /* width in horizontal writing mode */\n  block-size: 100vh;  /* height in horizontal writing mode */\n}\n```\n\n## Performance Optimizations\n\n### Content Visibility\n\n```css\n.long-list-item {\n  content-visibility: auto;\n  contain-intrinsic-size: 200px;\n}\n\n.off-screen-content {\n  content-visibility: hidden;\n}\n```\n\n### Container Style Queries\n\n```css\n.theme-container {\n  container-name: theme;\n  container-type: style;\n}\n\n@container style(--theme: dark) {\n  .card {\n    background: #1a1a1a;\n    color: white;\n  }\n}\n```\n\n## Conclusion\n\nThese modern CSS techniques represent a significant evolution in how we approach web styling. They enable more maintainable, performant, and flexible designs. While browser support varies, many of these features are already usable with progressive enhancement.\n\nStart incorporating these techniques into your projects gradually. The future of CSS is here, and it's more powerful than ever.",
    "publishedAt": "2023-12-10",
    "readTime": "6 min read",
    "tags": ["CSS", "Web Development", "Frontend", "Modern CSS"],
    "featured": false
  }
]
